"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[91699],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=a,h=d["".concat(l,".").concat(u)]||d[u]||c[u]||i;return n?o.createElement(h,r(r({ref:t},m),{},{components:n})):o.createElement(h,r({ref:t},m))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},12160:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>l,default:()=>g,frontMatter:()=>s,metadata:()=>p,toc:()=>c});n(67294);var o=n(3905);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function r(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}const s={title:"React Memo Guide with Examples",description:"Improve app performance with React.memo().",slug:"react-memo-guide",authors:"abdullah_numan",tags:["react"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/social2.png",hide_table_of_contents:!1},l=void 0,p={permalink:"/blog/react-memo-guide",source:"@site/blog/2024-01-16-react-memo.md",title:"React Memo Guide with Examples",description:"Improve app performance with React.memo().",date:"2024-01-16T00:00:00.000Z",formattedDate:"January 16, 2024",tags:[{label:"react",permalink:"/blog/tags/react"}],readingTime:13.81,hasTruncateMarker:!1,authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],frontMatter:{title:"React Memo Guide with Examples",description:"Improve app performance with React.memo().",slug:"react-memo-guide",authors:"abdullah_numan",tags:["react"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/social2.png",hide_table_of_contents:!1},prevItem:{title:"The Important Differences between URI VS URL",permalink:"/blog/uri-vs-url"},nextItem:{title:"Kubernetes Operators",permalink:"/blog/kubernetes-operators"},relatedPosts:[{title:"Creating a React search bar and content filtering components",description:"Article about how to create Search bar and filter component in React",permalink:"/blog/react-search-bar-and-filtering",formattedDate:"August 26, 2022",authors:[{name:"Madars Bi\u0161s",title:"Software Developer",url:"https://github.com/madzadev",imageURL:"https://github.com/madzadev.png",key:"madars_biss"}],readingTime:13.765,date:"2022-08-26T00:00:00.000Z"},{title:"Creating responsive tooltips in React with react-tooltip",description:"We'll explore how to create a custom tooltip component in a React application, as well as integrating the react-tooltip library.",permalink:"/blog/react-tooltip",formattedDate:"May 23, 2023",authors:[{name:"David Omotayo",title:"Frontend developer",url:"https://github.com/david4473",imageURL:"https://github.com/david4473.png",key:"david_omotayo"}],readingTime:13.47,date:"2023-05-23T00:00:00.000Z"},{title:"React Ecosystem in 2024 - Sustaining Popularity",description:"We'll look at the React ecosystem and the tools and libraries that have been created to support React.",permalink:"/blog/react-js-ecosystem-in-2024",formattedDate:"January 11, 2024",authors:[{name:"Chidume Nnamdi",title:"Software Engineer",url:"https://github.com/philipszdavido",imageURL:"https://github.com/philipszdavido.png",key:"chidume_nnamdi"}],readingTime:25.36,date:"2024-01-11T00:00:00.000Z"}],authorPosts:[{title:"How to use JavaScript Ternary Operator?",description:"In this post, we expound on with examples of what the JavaScript ternary operator is, how it works.",permalink:"/blog/javascript-ternary-operator",formattedDate:"November 15, 2022",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:4.06,date:"2022-11-15T00:00:00.000Z"},{title:"How to Use the TypeScript satisfies Operator",description:"TypeScript classes are a superset of JavaScript classes. This post covers the fundamentals of type annotations in TypeScript Classes and their associated quirks.",permalink:"/blog/typescript-satisfies-operator",formattedDate:"November 15, 2023",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:8.41,date:"2023-11-15T00:00:00.000Z"},{title:"React useMemo Hook Guide with Examples",description:"Improve React app performance with the useMemo() hook.",permalink:"/blog/react-usememo",formattedDate:"January 17, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:8.875,date:"2024-01-17T00:00:00.000Z"}]},m={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"What is Memoization?",id:"what-is-memoization",level:2},{value:"Why Memoization in React?",id:"why-memoization-in-react",level:2},{value:"Excessive Re-rendering Due to Ancestor Re-rendering",id:"excessive-re-rendering-due-to-ancestor-re-rendering",level:3},{value:"Expensive Utilities",id:"expensive-utilities",level:3},{value:"Passing Callbacks to Children",id:"passing-callbacks-to-children",level:3},{value:"Memoization in React",id:"memoization-in-react",level:2},{value:"About the React Memoization Series",id:"about-the-react-memoization-series",level:2},{value:"Project Overview",id:"project-overview",level:2},{value:"Setup",id:"setup",level:3},{value:"Investigation",id:"investigation",level:3},{value:"Memoizing a Functional Component using <code>React.memo()</code>",id:"memoizing-a-functional-component-using-reactmemo",level:2},{value:"What is <code>React.memo</code> ?",id:"what-is-reactmemo-",level:3},{value:"React.memo() - How to Memoize Component Props",id:"reactmemo---how-to-memoize-component-props",level:3},{value:"When to Use <code>React.memo</code>",id:"when-to-use-reactmemo",level:3},{value:"When Not to Use <code>React.memo</code>",id:"when-not-to-use-reactmemo",level:3},{value:"React.memo: Prop Comparison",id:"reactmemo-prop-comparison",level:3},{value:"Using React Memo with Custom Comparators",id:"using-react-memo-with-custom-comparators",level:3},{value:"Summary",id:"summary",level:2},{value:"Live Example",id:"live-example",level:2}],d=(u="CodeSandboxExample",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",e)});var u;const h={toc:c};function g(e){var{components:t}=e,n=r(e,["components"]);return(0,o.kt)("wrapper",i(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},o=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),o.forEach((function(t){a(e,t,n[t])}))}return e}({},h,n),{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"This article was last updated on January 16, 2024 to reflect the latest changes to the React memo API and to provide a more detailed explanation of how React.memo() works."))),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"This post introduces the ",(0,o.kt)("a",{parentName:"p",href:"https://refine.dev/blog/react-memo-guide/"},"React Memoization Series")," and demonstrates the usage of the ",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/memo"},(0,o.kt)("inlineCode",{parentName:"a"},"React.memo"))," API. ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo")," memoizes a functional component and its props. Doing so helps prevent unnecessary re-renderings that originate from the re-renderings of the component's parent / ancestors."),(0,o.kt)("p",null,"This is the first post of a three-part series hosted on ",(0,o.kt)("a",{parentName:"p",href:"https://refine.dev/blog"},"Refine blog")," on the use of memoization in React."),(0,o.kt)("p",null,"The other two posts in the series cover the usage of React ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useCallback()")," hooks."),(0,o.kt)("p",null,"Steps we'll cover in this post:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#what-is-memoization"},"What is Memoization?")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#why-memoization-in-react"},"Why Memoization in React?"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#excessive-re-rendering-due-to-ancestor-re-rendering"},"Excessive Re-rendering Due to Ancestor Re-rendering")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#expensive-utilities"},"Expensive Utilities")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#passing-callbacks-to-children"},"Passing Callbacks to Children")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#memoization-in-react"},"Memoization in React")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#about-the-react-memoization-series"},"About the React Memoization Series")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#memoizing-a-functional-component-using-reactmemo"},"Memoizing a Functional Component using ",(0,o.kt)("inlineCode",{parentName:"a"},"React.memo()")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#what-is-reactmemo-"},"What is ",(0,o.kt)("inlineCode",{parentName:"a"},"React.memo")," ?")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#reactmemo---how-to-memoize-component-props"},"React.memo() - How to Memoize Component Props")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#when-to-use-reactmemo"},"When to Use ",(0,o.kt)("inlineCode",{parentName:"a"},"React.memo"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#when-not-to-use-reactmemo"},"When Not to Use ",(0,o.kt)("inlineCode",{parentName:"a"},"React.memo"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#reactmemo-prop-comparison"},"React.memo: Prop Comparison")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#using-react-memo-with-custom-comparators"},"Using React Memo with Custom Comparators"))))),(0,o.kt)("h2",{id:"what-is-memoization"},"What is Memoization?"),(0,o.kt)("p",null,"Memoization is an performance optimization technique that allows us to minimize the use of memory and time while executing a resource-intensive function. It works by storing the last computed value or object from the function. Memoization lets us bypass the function's costly computations when the function is called with the same parameters repeatedly."),(0,o.kt)("h2",{id:"why-memoization-in-react"},"Why Memoization in React?"),(0,o.kt)("p",null,"Memoization plays a crucial role in enhancing the performance of a React component. It addresses following shortcomings in React:"),(0,o.kt)("h3",{id:"excessive-re-rendering-due-to-ancestor-re-rendering"},"Excessive Re-rendering Due to Ancestor Re-rendering"),(0,o.kt)("p",null,"React is all about re/rendering components in the virtual DOM prior to updating the actual Document Object Model in the browser. Re-render in an ancestor component, by default, triggers a re-render in a descendent component."),(0,o.kt)("p",null,"For example, a local state update in a parent component causes it to re-render. This, in turn, causes its children to re-render."),(0,o.kt)("p",null,"Such behavior in React causes a lot of memory and time to be wasted on useless renderings of the descendent components. Excessive re-renderings, therefore impact a React app's performance negatively."),(0,o.kt)("h3",{id:"expensive-utilities"},"Expensive Utilities"),(0,o.kt)("p",null,"In addition, resource intensive functions such as utilities used in data processing, transformation and manipulation lower a React app's performance. Functions used for sorting, filtering and mapping traverse large sets of data and therefore slows down an application."),(0,o.kt)("h3",{id:"passing-callbacks-to-children"},"Passing Callbacks to Children"),(0,o.kt)("p",null,"Performance of a React app is also adversely effected due to callback functions passed from a parent component to a child. This happens because a new function object from the callback is created in memory every time the child re-renders. So, multiple copies of the same callback function are spun off in runtime and they consume resources unnecessarily."),(0,o.kt)("h2",{id:"memoization-in-react"},"Memoization in React"),(0,o.kt)("p",null,"Using ",(0,o.kt)("strong",{parentName:"p"},"memoization")," the right way in React helps in mitigating these drawbacks and facilitates better use of computing resources in a React app."),(0,o.kt)("p",null,"Memoization can be used in a number of ways for optimizing the performance of a React app. React components can be memoized to prevent unnecessary component re-renders originating from ancestors participating in the component hierarchy. In functional React, component memoization is done using the ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo")," API."),(0,o.kt)("p",null,"Caching values of expensive utility functions and memoizing callbacks are two common ways of boosting a React app's performance. Caching function values is done using ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo()")," hook. And callback functions are memoized with the ",(0,o.kt)("inlineCode",{parentName:"p"},"useCallback()")," hook."),(0,o.kt)("h2",{id:"about-the-react-memoization-series"},"About the React Memoization Series"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"React Memoization Series")," is a three part guide on how to implement memoization in a React app. Each part demonstrates in the browser console how memoization contributes to performance optimization."),(0,o.kt)("p",null,"The three parts are:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"https://refine.dev/blog/react-memo-guide/"},"React Memo Guide with Examples")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"https://refine.dev/blog/react-usememo/"},"React useMemo Hook Guide With Examples")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"https://refine.dev/blog/react-usecallback-guide/"},"Memoization in React - How useCallback Works"))),(0,o.kt)("p",null,"In the first post, we implement memoizing a React component with ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo()")," and demonstrate how unnecessary re-renders coming from ancestor state updates are prevented. The second post covers how caching the value of an expensive utility function with ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo")," stops repetitive invocations of data heavy computations that slow down a React app. In the third part, we get an idea on how memoization of callbacks passed to child components helps reduce application memory consumption."),(0,o.kt)("p",null,"We will begin with an example that involves memoizing a functional component with ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo()"),". In the subsequent posts, we will gradually extend it to include use cases for the ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useCallback()")," hooks."),(0,o.kt)("h2",{id:"project-overview"},"Project Overview"),(0,o.kt)("p",null,"This series is a demo rather than a step-by-step coding tutorial. It is intended to demonstrate how memoization contributes to performance optimization in a React app. We've made the code available ",(0,o.kt)("a",{parentName:"p",href:"#live-stackblitz-example"},"here"),"."),(0,o.kt)("p",null,"All the components have been already coded. We'll be showing how memoization is implemented using ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useCallback")," APIs by examining relevant code snippets and highlighting lines on the existing components."),(0,o.kt)("p",null,"We'll follow the impact of memoization mainly from the browser's console."),(0,o.kt)("h3",{id:"setup"},"Setup"),(0,o.kt)("p",null,"In order to properly follow this tutorial, we recommend you run the app in a browser - since we will be visiting the console to investigate the impact of memoization on our React app."),(0,o.kt)("p",null,"For this to happen, please follow the below steps as outlined ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/refinedev/refine/tree/master/examples/blog-react-memoization-memo"},"here"),":"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Clone ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/refinedev/refine/tree/master/examples/blog-react-memoization-memo"},"this repository"),"."),(0,o.kt)("li",{parentName:"ol"},"Open it in your code editor and install the packages:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"yarn install\n")),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"Then run the app:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"yarn start\n")),(0,o.kt)("ol",{start:4},(0,o.kt)("li",{parentName:"ol"},"Open Google Chrome and navigate to ",(0,o.kt)("inlineCode",{parentName:"li"},"http://localhost:3000"),"."),(0,o.kt)("li",{parentName:"ol"},"Use ",(0,o.kt)("inlineCode",{parentName:"li"},"CTRL")," + ",(0,o.kt)("inlineCode",{parentName:"li"},"Shift")," + ",(0,o.kt)("inlineCode",{parentName:"li"},"J")," on Ubuntu or ",(0,o.kt)("inlineCode",{parentName:"li"},"Command")," + ",(0,o.kt)("inlineCode",{parentName:"li"},"Option")," + ",(0,o.kt)("inlineCode",{parentName:"li"},"J")," on Mac to inspect the webpage and open browser's console.")),(0,o.kt)("h3",{id:"investigation"},"Investigation"),(0,o.kt)("p",null,"If you look at the project folder in your code editor, you'll find that ",(0,o.kt)("inlineCode",{parentName:"p"},"react-memoization")," is created using ",(0,o.kt)("inlineCode",{parentName:"p"},"create-react-app"),"."),(0,o.kt)("p",null,"The app is based on the idea of a list of posts on a blog. There are several components involving a user presented the latest posts and a list of the user's posts. Allow yourself some time to understand the components individually, their relationships, their state changes, and how props are passed through. It is crucial to pay close attention to how the change of a parent's state triggers re-render of its descendants."),(0,o.kt)("p",null,"Let's dig into the components and check out what's happening."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"The ",(0,o.kt)("inlineCode",{parentName:"strong"},"<App />")," Component")),(0,o.kt)("p",null,"To begin with, we have an ",(0,o.kt)("inlineCode",{parentName:"p"},"<App />")," component that houses ",(0,o.kt)("inlineCode",{parentName:"p"},"<Blog />"),"."),(0,o.kt)("p",null,"If we look inside ",(0,o.kt)("inlineCode",{parentName:"p"},"<App />"),", we can see that we're storing a ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," state with ",(0,o.kt)("inlineCode",{parentName:"p"},"useState()")," hook. We also have a toggler function that alters the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/App.jsx"',title:'"src/components/App.jsx"'},'import { useState } from "react";\nimport Blog from "./components/Blog";\n\nfunction App() {\n  const [signedIn, setSignedIn] = useState(false);\n  const handleClick = () => setSignedIn(!signedIn);\n\n  console.log("Rendering App component");\n\n  return (\n    <main>\n      <nav>\n        <button onClick={handleClick}>Sign Out</button>\n      </nav>\n      <Blog signedIn={signedIn} setSignedIn={setSignedIn} />\n    </main>\n  );\n}\n\nexport default App;\n')),(0,o.kt)("p",null,"In the JSX, we pass ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"<Blog />"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"The ",(0,o.kt)("inlineCode",{parentName:"strong"},"<Blog />")," Component")),(0,o.kt)("p",null,"Looking inside ",(0,o.kt)("inlineCode",{parentName:"p"},"<Blog />"),", it fetches a list of posts with a click on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Get Latest Post")," button and sets the ",(0,o.kt)("inlineCode",{parentName:"p"},"updatedPosts")," state:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/Blog.jsx"',title:'"src/components/Blog.jsx"'},'import React, { useEffect, useMemo, useState } from "react";\nimport fetchUpdatedPosts from "../fetch/fetchUpdatedPosts";\nimport allPosts from "./../data/allPosts.json";\nimport sortPosts from "../utils/sortPosts";\nimport LatestPost from "./LatestPost";\nimport UserPostsIndex from "./UserPostsIndex";\n\nconst Blog = ({ signedIn }) => {\n  const [updatedPosts, setUpdatedPosts] = useState(allPosts);\n  const [localTime, setLocalTime] = useState(new Date().toLocaleTimeString());\n\n  const getLatestPosts = () => {\n    const posts = fetchUpdatedPosts();\n    setUpdatedPosts(posts);\n  };\n\n  const sortedPosts = sortPosts(updatedPosts);\n\n  useEffect(() => {\n    const id = setInterval(() => setLocalTime(new Date().toLocaleTimeString()), 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  console.log("Rendering Blog component");\n\n  return (\n    <div>\n      <div>{localTime}</div>\n      <button onClick={getLatestPosts}>Get Latest Post</button>\n      //highlight-next-line\n      <LatestPost signedIn={signedIn} post={sortedPosts[0]} />\n      <UserPostsIndex signedIn={signedIn} />\n    </div>\n  );\n};\n\nexport default Blog;\n')),(0,o.kt)("p",null,"We can see that the ",(0,o.kt)("inlineCode",{parentName:"p"},"updatedPosts")," are sorted with the ",(0,o.kt)("inlineCode",{parentName:"p"},"sortPosts")," utility and the first item from the sorted array is then passed to ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />")," component along with ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"The ",(0,o.kt)("inlineCode",{parentName:"strong"},"<LatestPost />")," Component")),(0,o.kt)("p",null,"Then coming to ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />"),", it nests the ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," component, which we are going to memoize with ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo()"),"."),(0,o.kt)("p",null,"Let's quickly run through ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />")," to see what it does:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/LatestPost.jsx"',title:'"src/components/LatestPost.jsx"'},'import React, { useEffect, useState } from "react";\nimport Post from "./Post";\n\nconst LatestPost = ({ signedIn, post }) => {\n  const [likesCount, setLikesCount] = useState(null);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setLikesCount((likesCount) => likesCount + 1);\n    }, 3000);\n\n    return () => clearInterval(id);\n  }, []);\n\n  console.log("Rendering LatestPost component");\n\n  return (\n    <div>\n      {post ? (\n        <>\n          //highlight-next-line\n          <Post signedIn={signedIn} post={post} />\n          {likesCount && (\n            <div className="my-1 p-1">\n              <span>{likesCount} Likes</span>\n            </div>\n          )}\n        </>\n      ) : (\n        <p>Click on Get Latest Post button</p>\n      )}\n    </div>\n  );\n};\n\nexport default LatestPost;\n')),(0,o.kt)("p",null,"We can see that ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />")," changes its local state of ",(0,o.kt)("inlineCode",{parentName:"p"},"likesCount")," every 3 seconds in the ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect()")," hook. Because of this, ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />")," should re-render every 3 seconds. So should ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," as a consequence of being a child of ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />"),":"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"The ",(0,o.kt)("inlineCode",{parentName:"strong"},"Post />")," Component")),(0,o.kt)("p",null,"Let's now focus on ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />"),". It receives ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"post")," as props and displays the content of ",(0,o.kt)("inlineCode",{parentName:"p"},"post"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/Post.jsx"',title:'"src/components/Post.jsx"'},'import React from "react";\n\nconst Post = ({ signedIn, post }) => {\n  console.log("Rendering Post component");\n\n  return (\n    <div className="">\n      {post && (\n        <div className="post p-1">\n          <h1 className="heading-sm py-1">{post.title}</h1>\n          <p>{post.body}</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Post;\n')),(0,o.kt)("p",null,"Notice we are logging to the console the event when ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," gets rendered: ",(0,o.kt)("inlineCode",{parentName:"p"},"console.log('Rendering Post component');")),(0,o.kt)("p",null,"When we check the console, we can expect to see that ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," is re-rendered with a change in ",(0,o.kt)("inlineCode",{parentName:"p"},"likesCount")," from ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />"),". This would be happening even though ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," does not depend on ",(0,o.kt)("inlineCode",{parentName:"p"},"likesCount"),"."),(0,o.kt)("p",null,"If we examine closely, we can see that this is indeed the case: we have ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," rendering again and again following an interval:"),(0,o.kt)("img",{style:{alignSelf:"center",width:"400px"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/memo1.png",alt:"memo1"}),(0,o.kt)("br",null),(0,o.kt)("p",null,"Notice, rendering ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," is accompanied by ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />")," at 3 seonds interval, so it is consistent that ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />"),"'s re-renders are happening due to ",(0,o.kt)("inlineCode",{parentName:"p"},"likesCount")," state changes in ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />"),". That is, they are coming at ",(0,o.kt)("inlineCode",{parentName:"p"},"3000ms")," intervals from ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />"),"'s ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect()")," hook."),(0,o.kt)("p",null,"All these re-renders are futile for ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," and costly for the app. So we are going to prevent them using component memoization."),(0,o.kt)("h2",{id:"memoizing-a-functional-component-using-reactmemo"},"Memoizing a Functional Component using ",(0,o.kt)("inlineCode",{parentName:"h2"},"React.memo()")),(0,o.kt)("p",null,"Now, if we memoize ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo()"),", the re-renders should stop."),(0,o.kt)("p",null,"So, in ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />"),", let's update the component export with the highlighted code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/Post.jsx"',title:'"src/components/Post.jsx"'},"const Post = ({ signedIn, post }) => {\n\nconsole.log('Rendering Post component');\n\n  return ( ... );\n};\n\n//highlight-next-line\nexport default React.memo(Post);\n")),(0,o.kt)("p",null,"Looking at the console, we can see that ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," is no longer re-rendered at 3s intervals:"),(0,o.kt)("img",{style:{alignSelf:"center",width:"400px"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/memo2.png",alt:"memo2"}),(0,o.kt)("br",null),(0,o.kt)("p",null,"It is clear that memoizing ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," reduces the number of re-renders. In a real app, this is a huge blessing because re-renders due to frequent likes turn out to be very costly for a social media app's performance."),(0,o.kt)("p",null,"But what exactly happened?"),(0,o.kt)("h3",{id:"what-is-reactmemo-"},"What is ",(0,o.kt)("inlineCode",{parentName:"h3"},"React.memo")," ?"),(0,o.kt)("p",null,"Well, with ",(0,o.kt)("inlineCode",{parentName:"p"},"export default React.memo(Post);"),", we produced a new component that re-renders only when its props and internal state is changed."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"React.memo()")," is a Higher Order Component (HOC) that memoizes the passed in component along with the value of its props. Doing so helps in optimizing its performance by preventing unnecessary re-renders due to changes it does not depend on, e.g. the unrelated state changes in ancestor components."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"React.memo")," does this by memoizing the component function itself and the accepted props. When the values of the props change, the component re-renders."),(0,o.kt)("h3",{id:"reactmemo---how-to-memoize-component-props"},"React.memo() - How to Memoize Component Props"),(0,o.kt)("p",null,"We can see that ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," receives ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"post")," props."),(0,o.kt)("p",null,"Now, unlike with ",(0,o.kt)("inlineCode",{parentName:"p"},"likesCount"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," ",(0,o.kt)("strong",{parentName:"p"},"depends on")," ",(0,o.kt)("inlineCode",{parentName:"p"},"signIn")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"post"),". And ",(0,o.kt)("strong",{parentName:"p"},"React memo")," caches these props and checks for incoming changes in them. Incoming changes to them triggers a re-render. So, altering any of ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"post")," re-renders ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),"."),(0,o.kt)("p",null,"If we look back inside ",(0,o.kt)("inlineCode",{parentName:"p"},"<App />"),", we see that ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," originated from there and gets relayed via ",(0,o.kt)("inlineCode",{parentName:"p"},"<Blog />")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," as props. We have a button in the navbar that toggles the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'<nav className="navbar">\n  <button className="btn btn-danger" onClick={handleClick}>\n    Sign Out\n  </button>\n</nav>\n')),(0,o.kt)("p",null,"In the browser, let's try toggling its value to see the effect on memoized ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />"),"."),(0,o.kt)("p",null,"Add the following console log statement to ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," in order to log the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," to the console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"//highlight-next-line\nconsole.log(signedIn);\n")),(0,o.kt)("p",null,"When we click on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Sign Out")," button in the navbar, we can see in the console that ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," re-renders after ",(0,o.kt)("inlineCode",{parentName:"p"},"<LatestPost />"),":"),(0,o.kt)("img",{width:"400px",src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/memo3.png",style:{alignSelf:"center"},alt:"memo3"}),(0,o.kt)("br",null),(0,o.kt)("p",null,"This is now because ",(0,o.kt)("strong",{parentName:"p"},"React memo")," caches the props passed to the component and checks for incoming changes. Notice the Boolean value of ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," printed to the console. A change in ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn"),"'s state renews the memoization and a re-render of the component is triggered."),(0,o.kt)("h3",{id:"when-to-use-reactmemo"},"When to Use ",(0,o.kt)("inlineCode",{parentName:"h3"},"React.memo")),(0,o.kt)("p",null,"This is actually what we want. Because we don't want ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," to re-render when we don't need it to, and we want to re-render it when we need it to."),(0,o.kt)("p",null,"If value of ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," never changed, we know ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," will never be re-rendered because of ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn"),". In that case, caching ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," doesn't do us any favor."),(0,o.kt)("p",null,"So, typically we should use ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo")," when we want to prevent re-renderings due to state changes that do not concern our component and only allow re-renderings due to prop changes that happen often or are driven by an event."),(0,o.kt)("h3",{id:"when-not-to-use-reactmemo"},"When Not to Use ",(0,o.kt)("inlineCode",{parentName:"h3"},"React.memo")),(0,o.kt)("p",null,"In our example, had we resorted to ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo()")," solely to retain the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," and ",(0,o.kt)("strong",{parentName:"p"},"not")," to prevent re-renders due to changes in ",(0,o.kt)("inlineCode",{parentName:"p"},"likesCount")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"post"),", we would not get much performance benefit."),(0,o.kt)("p",null,"Instead, we would be bringing the comparison function into the scene for no reason, which adds to the performance cost. So, it is ",(0,o.kt)("strong",{parentName:"p"},"not")," recommended to memoize a component if its prop values ",(0,o.kt)("strong",{parentName:"p"},"don't")," change often."),(0,o.kt)("p",null,"It is therefore important to figure out the performance gains by measuring and analyzing runtime performance using browser utilities like Chrome DevTools."),(0,o.kt)("h3",{id:"reactmemo-prop-comparison"},"React.memo: Prop Comparison"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"React memo")," checks for changes between the previous and current values for a given prop passed to the component. The default function carries out a shallow comparison on each passed in prop. It checks for equality of incoming values with the existing ones."),(0,o.kt)("p",null,"In our ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo(Post)")," memo, the current states of ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"post")," are checked for equality to their incoming states. If both values for each prop are equal, the memoized value is retained and re-render prevented. If they are not equal, the new value is cached and ",(0,o.kt)("inlineCode",{parentName:"p"},"<Post />")," re-renders."),(0,o.kt)("h3",{id:"using-react-memo-with-custom-comparators"},"Using React Memo with Custom Comparators"),(0,o.kt)("p",null,"It is possible to customize the comparison by passing in a comparator function to the ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo()")," HOC as a second argument:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"React.memo(Post, customComparator);\n")),(0,o.kt)("p",null,"For example, we can specify dependencies for ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo()")," and choose to compare only the props we want to:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/Post.jsx"',title:'"src/components/Post.jsx"'},'import React from "react";\n\nconst Post = ({ signedIn, post }) => {\n  console.log("Rendering Post component");\n\n  return ( ... );\n};\n\n//highlight-start\nconst customComparator = (prevProps, nextProps) => {\n  return nextProps.post === prevProps.post;\n};\n//highlight-end\n\n//highlight-start\nexport default React.memo(Post, customComparator);\n//highlight-end\n')),(0,o.kt)("p",null,"Here, we are omitting ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," from the comparison by including only ",(0,o.kt)("inlineCode",{parentName:"p"},"post"),". Now, if we click on ",(0,o.kt)("inlineCode",{parentName:"p"},"Sign Out")," button, ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," is not being re-rendered:"),(0,o.kt)("img",{style:{alignSelf:"center",width:"400px"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/memo4.png",alt:"memo4"}),(0,o.kt)("br",null),(0,o.kt)("p",null,"This is because, our ",(0,o.kt)("inlineCode",{parentName:"p"},"customComparator")," checks for equality of incoming values of only ",(0,o.kt)("inlineCode",{parentName:"p"},"post")," and excludes ",(0,o.kt)("inlineCode",{parentName:"p"},"signedIn")," from the comparison."),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"In this post, we acknowledged what memoization is and why it is important in React. We learned about the use of ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useCallback")," APIs for implementing memoization in a React app."),(0,o.kt)("p",null,"By investigating a demo blog post app, we observed in the browser console that ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo()")," is very useful in preventing unnecessary, frequent re-renders of a component due to ancestor state changes that it does not depend on. A good example involves a component that accepts props whose values change often and/or on demand. With a ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo")," custom comparator function, we can choose to specify only the props we want to track for triggering a re-render of our component."),(0,o.kt)("p",null,"In the next article, we will turn our attention to the ",(0,o.kt)("inlineCode",{parentName:"p"},"<Blog />")," component and memoize a sorting function with ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo()")," hook."),(0,o.kt)("h2",{id:"live-example"},"Live Example"),(0,o.kt)(d,{path:"blog-react-memoization-memo",mdxType:"CodeSandboxExample"}))}g.isMDXComponent=!0}}]);